<!DOCTYPE html>
<html lang="ru">
<head>
        <meta charset="UTF-8">
        <title>Dragons vs Zombies Chess</title>
        <style>
            body {
                margin: 0;
                background-color: #333;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                font-family: Arial, sans-serif;
                color: #fff;
            }
            #gameCanvas {
                border: 2px solid #fff;
                background-color: #769656;
            }
            #info {
                position: absolute;
                top: 20px;
                text-align: center;
                z-index: 1;
                background: rgba(0, 0, 0, 0.7);
                padding: 10px 20px;
                border-radius: 10px;
            }
            #info p {
                margin: 5px 0;
            }
        </style>
</head>
<body>
        <div id="info">
            <h1>Dragons vs Zombies Chess</h1>
            <p>Turn: <span id="turn">Dragons</span></p>
            <p>Scope: <span id="score">0</span></p>
            <p>Press <strong> Space</strong> to BURN THEM ALL</p>
        </div>
        <canvas id="gameCanvas" width="480" height="480"></canvas>


        <script>
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const turnElement = document.getElementById('turn');
            const scoreElement = document.getElementById('score');


            const tileSize = 60;
            const boardSize = 8;


            let selectedPiece = null;
            let currentTurn = 'white';
            let gameOver = false;
            let score = 0;


            // Figures Values
            const pieceValues = {
                'pawn': 1,
                'knight': 3.5,
                'bishop': 3.5,
                'rook': 5,
                'queen': 9,
                'king': 1000
            };


            // initialize Board
            let board = initializeBoard();


            function initializeBoard() {
                const newBoard = [];
                for (let row = 0; row < boardSize; row++) {
                    newBoard[row] = [];
                    for (let col = 0; col < boardSize; col++) {
                        newBoard[row][col] = null;
                    }
                }


                // Расстановка фигур
                const backRank = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                for (let col = 0; col < boardSize; col++) {
                    // Черные фигуры
                    newBoard[0][col] = { type: backRank[col], color: 'black' };
                    newBoard[1][col] = { type: 'pawn', color: 'black' };
                    newBoard[2][col] = { type: 'pawn', color: 'black' }; // Дополнительные пешки
                    newBoard[3][col] = { type: 'pawn', color: 'black' }; // Еще один ряд пешек
                    // Белые фигуры
                    newBoard[6][col] = { type: 'pawn', color: 'white', salvoCooldown: 0 };
                    newBoard[7][col] = { type: backRank[col], color: 'white' };
                }


                // Добавление дополнительных черных слонов на 4-й и 5-й линии
                newBoard[3][2] = { type: 'bishop', color: 'black' };
                newBoard[3][5] = { type: 'bishop', color: 'black' };
                newBoard[4][2] = { type: 'bishop', color: 'black' };
                newBoard[4][5] = { type: 'bishop', color: 'black' };


                return newBoard;
            }


            // Рендеринг доски
            function drawBoard() {
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        // Чередование цветов клеток
                        if ((row + col) % 2 === 0) {
                            ctx.fillStyle = '#eeeed2';
                        } else {
                            ctx.fillStyle = '#769656';
                        }
                        ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);


                        // Отображение фигур
                        const piece = board[row][col];
                        if (piece) {
                            ctx.fillStyle = piece.color === 'white' ? '#fff' : '#000';
                            ctx.font = '40px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(getPieceSymbol(piece), col * tileSize + tileSize / 2, row * tileSize + tileSize / 2);
                        }
                    }
                }


                // Подсветка выбранной фигуры и возможных ходов
                if (selectedPiece) {
                    const from = selectedPiece.from;
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(from.col * tileSize, from.row * tileSize, tileSize, tileSize);
                    // Подсветка возможных ходов
                    selectedPiece.moves.forEach(move => {
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        ctx.fillRect(move.col * tileSize, move.row * tileSize, tileSize, tileSize);
                    });
                }
            }


            // Получение символа для фигуры
            function getPieceSymbol(piece) {
                const symbols = {
                    'pawn': '♟',
                    'rook': '♜',
                    'knight': '♞',
                    'bishop': '♝',
                    'queen': '♛',
                    'king': '♚'
                };
                return symbols[piece.type] || '';
            }


            // Обработка кликов по доске
            canvas.addEventListener('click', handleClick);
            window.addEventListener('keydown', handleKeyPress);


            function handleClick(event) {
                if (gameOver) return;


                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;


                const col = Math.floor(x / tileSize);
                const row = Math.floor(y / tileSize);


                if (selectedPiece) {
                    // Попытка сделать ход
                    const to = { row, col };
                    const isValid = selectedPiece.moves.some(move => move.row === to.row && move.col === to.col);


                    if (isValid) {
                        makeMove(selectedPiece.from, to);
                        selectedPiece = null;
                        currentTurn = currentTurn === 'white' ? 'black' : 'white';
                        turnElement.textContent = currentTurn === 'white' ? 'Белые' : 'Черные';
                        drawBoard();


                        // Ход AI, если сейчас черные
                        if (currentTurn === 'black' && !gameOver) {
                            setTimeout(() => {
                                const aiMove = getAIMove(board, 'black');
                                if (aiMove) {
                                    makeMove(aiMove.from, aiMove.to);
                                    currentTurn = 'white';
                                    turnElement.textContent = 'Белые';
                                    drawBoard();
                                }
                            }, 500); // Задержка для плавности
                        }
                    } else {
                        // Если ход невалидный, снять выделение
                        selectedPiece = null;
                        drawBoard();
                    }
                } else {
                    // Выбор фигуры
                    const piece = board[row][col];
                    if (piece && piece.color === currentTurn) {
                        const validMoves = getValidMoves(board, row, col);
                        if (validMoves.length > 0) {
                            selectedPiece = { from: { row, col }, moves: validMoves };
                            drawBoard();
                        }
                    }
                }
            }


            // Обработка нажатия клавиш для специальных способностей
            function handleKeyPress(event) {
                if (gameOver) return;
                // Проверка нажатия пробела (Spacebar)
                if (event.code === 'Space' && currentTurn === 'white') {
                    event.preventDefault(); // Предотвращение прокрутки страницы
                    performAllSalvos();
                }
            }


            // Выполнение залпа для всех белых пешек с готовностью
            function performAllSalvos() {
                let anySalvoPerformed = false;


                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece && piece.type === 'pawn' && piece.color === 'white' && piece.salvoCooldown === 0) {
                            performSalvo(row, col);
                            piece.salvoCooldown = 10; // Устанавливаем кулдаун
                            anySalvoPerformed = true;
                        }
                    }
                }


                if (anySalvoPerformed) {
                    drawBoard();
                } else {
                    alert('FIRE on RELOAD, please wait');
                }
            }


            // Выполнение залпа пешкой
            function performSalvo(row, col) {
                const direction = -1; // Белые движутся вверх
                let targetRow = row + direction;
                while (isInside(targetRow, col)) {
                    const targetPiece = board[targetRow][col];
                    if (targetPiece) {
                        if (targetPiece.type === 'king') {
                            gameOver = true;
                            alert('You won but with what price!');
                            document.location.reload();
                            return;
                        } else {
                            score += pieceValues[targetPiece.type];
                            scoreElement.textContent = score;
                            board[targetRow][col] = null;
                        }
                    }
                    targetRow += direction;
                }
            }


            // Выполнение хода
            function makeMove(from, to) {
                const movingPiece = board[from.row][from.col];
                const targetPiece = board[to.row][to.col];


                // Захват фигуры
                if (targetPiece) {
                    score += pieceValues[targetPiece.type];
                    scoreElement.textContent = score;
                    // Проверка мата
                    if (targetPiece.type === 'king') {
                        gameOver = true;
                        setTimeout(() => {
                            alert(`${movingPiece.color === 'white' ? 'Dragons' : 'Zombies'} won!`);
                            document.location.reload();
                        }, 100);
                    }
                }


                // Перемещение фигуры
                board[to.row][to.col] = movingPiece;
                board[from.row][from.col] = null;


                // Пешечное превращение
                if (movingPiece.type === 'pawn') {
                    if ((movingPiece.color === 'white' && to.row === 0) || (movingPiece.color === 'black' && to.row === 7)) {
                        board[to.row][to.col] = { type: 'queen', color: movingPiece.color };
                    }
                }


                // Уменьшение кулдауна залпов для всех белых пешек
                if (movingPiece.color === 'white') {
                    for (let r = 0; r < boardSize; r++) {
                        for (let c = 0; c < boardSize; c++) {
                            const p = board[r][c];
                            if (p && p.type === 'pawn' && p.color === 'white' && p.salvoCooldown > 0) {
                                p.salvoCooldown--;
                            }
                        }
                    }
                }
            }


            // Копирование доски
            function copyBoard(board) {
                return board.map(row => row.map(piece => {
                    if (piece === null) return null;
                    return { type: piece.type, color: piece.color, salvoCooldown: piece.salvoCooldown || 0 };
                }));
            }


            // Оценка доски
            function evaluateBoard(board, turn) {
                let score = 0;


                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece) {
                            if (piece.color === turn) {
                                score += pieceValues[piece.type];
                            } else {
                                score -= pieceValues[piece.type];
                            }
                        }
                    }
                }


                return score;
            }


            // Генерация всех возможных ходов для игрока
            function generateAllMoves(board, turn) {
                const moves = [];
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === turn) {
                            const pieceMoves = getValidMoves(board, row, col);
                            pieceMoves.forEach(move => {
                                moves.push({
                                    from: { row, col },
                                    to: { row: move.row, col: move.col }
                                });
                            });
                        }
                    }
                }
                return moves;
            }


            // Оценка хода AI с приоритетом захвата и защитой короля
            function getAIMove(board, turn) {
                const moves = generateAllMoves(board, turn);
                if (moves.length === 0) return null;


                let bestScore = -Infinity;
                let bestMove = null;


                // Проверяем, находится ли король под шахом
                const inCheck = isInCheck(board, 'black');


                // Фильтруем ходы, которые снимают шах, если король под шахом
                const filteredMoves = inCheck ? moves.filter(move => {
                    const boardCopy = copyBoard(board);
                    const movingPiece = boardCopy[move.from.row][move.from.col];
                    const targetPiece = boardCopy[move.to.row][move.to.col];


                    // Выполнение хода на копии доски
                    boardCopy[move.to.row][move.to.col] = movingPiece;
                    boardCopy[move.from.row][move.from.col] = null;


                    // Пешечное превращение
                    if (movingPiece.type === 'pawn') {
                        if ((movingPiece.color === 'black' && move.to.row === 7)) {
                            boardCopy[move.to.row][move.to.col] = { type: 'queen', color: movingPiece.color };
                        }
                    }


                    // Проверка, снят ли шах после хода
                    return !isInCheck(boardCopy, 'black');
                }) : moves;


                // Если король под шахом и нет доступных ходов, объявляем шахматную ситуацию
                if (inCheck && filteredMoves.length === 0) {
                    gameOver = true;
                    alert('Mat! Mission accomplished!RISE You are great! You safe others zombies');
                    document.location.reload();
                    return null;
                }


                // Используем отфильтрованные ходы
                filteredMoves.forEach(move => {
                    const boardCopy = copyBoard(board);
                    const movingPiece = boardCopy[move.from.row][move.from.col];
                    const targetPiece = boardCopy[move.to.row][move.to.col];


                    // Выполнение хода на копии доски
                    boardCopy[move.to.row][move.to.col] = movingPiece;
                    boardCopy[move.from.row][move.from.col] = null;


                    // Пешечное превращение
                    if (movingPiece.type === 'pawn') {
                        if ((movingPiece.color === 'black' && move.to.row === 7)) {
                            boardCopy[move.to.row][move.to.col] = { type: 'queen', color: movingPiece.color };
                        }
                    }


                    // Оценка хода
                    let moveScore = evaluateBoard(boardCopy, turn);


                    // Приоритет захвата
                    if (targetPiece) {
                        moveScore += pieceValues[targetPiece.type] * 2; // Увеличиваем оценку за захват
                    }


                    // Приоритет продвижения пешек
                    if (movingPiece.type === 'pawn') {
                        moveScore += (move.to.row - 1); // Чем дальше пешка, тем выше оценка
                    }


                    // Приоритет постановки вилки конем
                    if (movingPiece.type === 'knight') {
                        const potentialForks = countForks(boardCopy, move.to.row, move.to.col, turn);
                        moveScore += potentialForks * 1.5; // Увеличиваем оценку за вилки
                    }


                    // Защита короля: дополнительные баллы за расстояние от короля до белых фигур
                    const kingPos = findKingPosition(boardCopy, 'black');
                    if (kingPos) {
                        const distance = Math.abs(kingPos.row - move.to.row) + Math.abs(kingPos.col - move.to.col);
                        moveScore += (8 - distance) * 0.5; // Чем ближе король к центру/безопасным позициям, тем выше оценка
                    }


                    // Защита пешек: дополнительные баллы за защиту пешек
                    moveScore += evaluatePawnProtection(boardCopy, 'black') * 0.3;


                    if (moveScore > bestScore) {
                        bestScore = moveScore;
                        bestMove = move;
                    }
                });


                // Если нет фильтруемых ходов, используем все доступные
                if (!inCheck) {
                    moves.forEach(move => {
                        const boardCopy = copyBoard(board);
                        const movingPiece = boardCopy[move.from.row][move.from.col];
                        const targetPiece = boardCopy[move.to.row][move.to.col];


                        // Выполнение хода на копии доски
                        boardCopy[move.to.row][move.to.col] = movingPiece;
                        boardCopy[move.from.row][move.from.col] = null;


                        // Пешечное превращение
                        if (movingPiece.type === 'pawn') {
                            if ((movingPiece.color === 'black' && move.to.row === 7)) {
                                boardCopy[move.to.row][move.to.col] = { type: 'queen', color: movingPiece.color };
                            }
                        }


                        // Оценка хода
                        let moveScore = evaluateBoard(boardCopy, turn);


                        // Приоритет захвата
                        if (targetPiece) {
                            moveScore += pieceValues[targetPiece.type] * 2; // Увеличиваем оценку за захват
                        }


                        // Приоритет продвижения пешек
                        if (movingPiece.type === 'pawn') {
                            moveScore += (move.to.row - 1); // Чем дальше пешка, тем выше оценка
                        }


                        // Приоритет постановки вилки конем
                        if (movingPiece.type === 'knight') {
                            const potentialForks = countForks(boardCopy, move.to.row, move.to.col, turn);
                            moveScore += potentialForks * 1.5; // Увеличиваем оценку за вилки
                        }


                        // Защита короля: дополнительные баллы за расстояние от короля до белых фигур
                        const kingPos = findKingPosition(boardCopy, 'black');
                        if (kingPos) {
                            const distance = Math.abs(kingPos.row - move.to.row) + Math.abs(kingPos.col - move.to.col);
                            moveScore += (8 - distance) * 0.5; // Чем ближе король к центру/безопасным позициям, тем выше оценка
                        }


                        // Защита пешек: дополнительные баллы за защиту пешек
                        moveScore += evaluatePawnProtection(boardCopy, 'black') * 0.3;


                        if (moveScore > bestScore) {
                            bestScore = moveScore;
                            bestMove = move;
                        }
                    });
                }


                return bestMove;
            }


            // Подсчет количества возможных вилок конем
            function countForks(board, row, col, turn) {
                let forks = 0;
                const knightMoves = [
                    { row: -2, col: -1 }, { row: -2, col: 1 },
                    { row: -1, col: -2 }, { row: -1, col: 2 },
                    { row: 1, col: -2 }, { row: 1, col: 2 },
                    { row: 2, col: -1 }, { row: 2, col: 1 }
                ];


                knightMoves.forEach(dir => {
                    const newRow = row + dir.row;
                    const newCol = col + dir.col;
                    if (isInside(newRow, newCol)) {
                        const piece = board[newRow][newCol];
                        if (piece && piece.color !== turn && piece.type !== 'king') {
                            forks++;
                        }
                    }
                });


                return forks;
            }


            // Найти позицию короля
            function findKingPosition(board, color) {
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece && piece.type === 'king' && piece.color === color) {
                            return { row, col };
                        }
                    }
                }
                return null;
            }


            // Проверка, находится ли король в шахе
            function isInCheck(board, color) {
                const kingPos = findKingPosition(board, color);
                if (!kingPos) return false; // Король не найден, возможно, игра закончена


                // Проверка всех фигур противника на возможность атаковать короля
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color !== color) {
                            const moves = getValidMoves(board, row, col);
                            if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                                return true;
                            }
                        }
                    }
                }


                return false;
            }


            // Проверка допустимых ходов для фигуры
            function getValidMoves(board, row, col) {
                const piece = board[row][col];
                if (!piece) return [];
                const directions = {
                    'pawn': [
                        { row: piece.color === 'white' ? -1 : 1, col: 0 },
                        { row: piece.color === 'white' ? -2 : 2, col: 0 },
                        { row: piece.color === 'white' ? -1 : 1, col: -1 },
                        { row: piece.color === 'white' ? -1 : 1, col: 1 },
                    ],
                    'rook': [
                        { row: -1, col: 0 }, { row: 1, col: 0 },
                        { row: 0, col: -1 }, { row: 0, col: 1 }
                    ],
                    'knight': [
                        { row: -2, col: -1 }, { row: -2, col: 1 },
                        { row: -1, col: -2 }, { row: -1, col: 2 },
                        { row: 1, col: -2 }, { row: 1, col: 2 },
                        { row: 2, col: -1 }, { row: 2, col: 1 }
                    ],
                    'bishop': [
                        { row: -1, col: -1 }, { row: -1, col: 1 },
                        { row: 1, col: -1 }, { row: 1, col: 1 }
                    ],
                    'queen': [
                        { row: -1, col: 0 }, { row: 1, col: 0 },
                        { row: 0, col: -1 }, { row: 0, col: 1 },
                        { row: -1, col: -1 }, { row: -1, col: 1 },
                        { row: 1, col: -1 }, { row: 1, col: 1 }
                    ],
                    'king': [
                        { row: -1, col: 0 }, { row: 1, col: 0 },
                        { row: 0, col: -1 }, { row: 0, col: 1 },
                        { row: -1, col: -1 }, { row: -1, col: 1 },
                        { row: 1, col: -1 }, { row: 1, col: 1 }
                    ]
                };


                let possibleMoves = [];


                if (piece.type === 'pawn') {
                    // Один шаг вперед
                    const direction = piece.color === 'white' ? -1 : 1;
                    const nextRow = row + direction;
                    if (isEmpty(board, nextRow, col)) {
                        possibleMoves.push({ row: nextRow, col });
                        // Два шага вперед с начальной позиции
                        const startRow = piece.color === 'white' ? 6 : 1;
                        const twoStepRow = row + 2 * direction;
                        if (row === startRow && isEmpty(board, twoStepRow, col)) {
                            possibleMoves.push({ row: twoStepRow, col });
                        }
                    }
                    // Взятие диагонально
                    if (isEnemy(board, row + direction, col - 1, piece.color)) {
                        possibleMoves.push({ row: row + direction, col: col - 1 });
                    }
                    if (isEnemy(board, row + direction, col + 1, piece.color)) {
                        possibleMoves.push({ row: row + direction, col: col + 1 });
                    }
                } else if (piece.type === 'knight') {
                    directions['knight'].forEach(dir => {
                        const newRow = row + dir.row;
                        const newCol = col + dir.col;
                        if (isInside(newRow, newCol)) {
                            if (isEmpty(board, newRow, newCol) || isEnemy(board, newRow, newCol, piece.color)) {
                                possibleMoves.push({ row: newRow, col: newCol });
                            }
                        }
                    });
                } else {
                    const pieceDirections = directions[piece.type];
                    pieceDirections.forEach(dir => {
                        let newRow = row + dir.row;
                        let newCol = col + dir.col;
                        while (isInside(newRow, newCol)) {
                            if (isEmpty(board, newRow, newCol)) {
                                possibleMoves.push({ row: newRow, col: newCol });
                            } else {
                                if (isEnemy(board, newRow, newCol, piece.color)) {
                                    possibleMoves.push({ row: newRow, col: newCol });
                                }
                                break; // Нельзя прыгать через фигуры
                            }
                            // Для короля движение только на одну клетку
                            if (piece.type === 'king') break;
                            newRow += dir.row;
                            newCol += dir.col;
                        }
                    });
                }


                return possibleMoves;
            }


            // Проверка, что клетка пуста
            function isEmpty(board, row, col) {
                if (!isInside(row, col)) return false;
                return board[row][col] === null;
            }


            // Проверка, что клетка занята фигурой противника
            function isEnemy(board, row, col, color) {
                if (!isInside(row, col)) return false;
                const piece = board[row][col];
                return piece !== null && piece.color !== color;
            }


            // Проверка, что координаты внутри доски
            function isInside(row, col) {
                return row >= 0 && row < boardSize && col >= 0 && col < boardSize;
            }


            // Найти позицию короля
            function findKingPosition(board, color) {
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece && piece.type === 'king' && piece.color === color) {
                            return { row, col };
                        }
                    }
                }
                return null;
            }


            // Проверка, находится ли король в шахе
            function isInCheck(board, color) {
                const kingPos = findKingPosition(board, color);
                if (!kingPos) return false; // Король не найден, возможно, игра закончена


                // Проверка всех фигур противника на возможность атаковать короля
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color !== color) {
                            const moves = getValidMoves(board, row, col);
                            if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                                return true;
                            }
                        }
                    }
                }


                return false;
            }


            // Оценка доски
            function evaluateBoard(board, turn) {
                let score = 0;


                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece) {
                            if (piece.color === turn) {
                                score += pieceValues[piece.type];
                            } else {
                                score -= pieceValues[piece.type];
                            }
                        }
                    }
                }


                return score;
            }


            // Генерация всех возможных ходов для игрока
            function generateAllMoves(board, turn) {
                const moves = [];
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === turn) {
                            const pieceMoves = getValidMoves(board, row, col);
                            pieceMoves.forEach(move => {
                                moves.push({
                                    from: { row, col },
                                    to: { row: move.row, col: move.col }
                                });
                            });
                        }
                    }
                }
                return moves;
            }


            // Оценка хода AI с приоритетом захвата и защитой короля
            function getAIMove(board, turn) {
                const moves = generateAllMoves(board, turn);
                if (moves.length === 0) return null;


                let bestScore = -Infinity;
                let bestMove = null;


                // Проверяем, находится ли король под шахом
                const inCheck = isInCheck(board, 'black');


                // Фильтруем ходы, которые снимают шах, если король под шахом
                const filteredMoves = inCheck ? moves.filter(move => {
                    const boardCopy = copyBoard(board);
                    const movingPiece = boardCopy[move.from.row][move.from.col];
                    const targetPiece = boardCopy[move.to.row][move.to.col];


                    // Выполнение хода на копии доски
                    boardCopy[move.to.row][move.to.col] = movingPiece;
                    boardCopy[move.from.row][move.from.col] = null;


                    // Пешечное превращение
                    if (movingPiece.type === 'pawn') {
                        if ((movingPiece.color === 'black' && move.to.row === 7)) {
                            boardCopy[move.to.row][move.to.col] = { type: 'queen', color: movingPiece.color };
                        }
                    }


                    // Проверка, снят ли шах после хода
                    return !isInCheck(boardCopy, 'black');
                }) : moves;


                // Если король под шахом и нет доступных ходов, объявляем шахматную ситуацию
                if (inCheck && filteredMoves.length === 0) {
                    gameOver = true;
                    alert('Mat! You win and safe others! You are GREATE!');
                    document.location.reload();
                    return null;
                }


                // Используем отфильтрованные ходы
                filteredMoves.forEach(move => {
                    const boardCopy = copyBoard(board);
                    const movingPiece = boardCopy[move.from.row][move.from.col];
                    const targetPiece = boardCopy[move.to.row][move.to.col];


                    // Выполнение хода на копии доски
                    boardCopy[move.to.row][move.to.col] = movingPiece;
                    boardCopy[move.from.row][move.from.col] = null;


                    // Пешечное превращение
                    if (movingPiece.type === 'pawn') {
                        if ((movingPiece.color === 'black' && move.to.row === 7)) {
                            boardCopy[move.to.row][move.to.col] = { type: 'queen', color: movingPiece.color };
                        }
                    }


                    // Оценка хода
                    let moveScore = evaluateBoard(boardCopy, turn);


                    // Приоритет захвата
                    if (targetPiece) {
                        moveScore += pieceValues[targetPiece.type] * 2; // Увеличиваем оценку за захват
                    }


                    // Приоритет продвижения пешек
                    if (movingPiece.type === 'pawn') {
                        moveScore += (movingPiece.color === 'black' ? (move.to.row - 1) : (6 - move.to.row)); // Для черных и белых пешек
                    }


                    // Приоритет постановки вилки конем
                    if (movingPiece.type === 'knight') {
                        const potentialForks = countForks(boardCopy, move.to.row, move.to.col, turn);
                        moveScore += potentialForks * 1.5; // Увеличиваем оценку за вилки
                    }


                    // Защита короля: дополнительные баллы за расстояние от короля до белых фигур
                    const kingPos = findKingPosition(boardCopy, 'black');
                    if (kingPos) {
                        const distance = Math.abs(kingPos.row - move.to.row) + Math.abs(kingPos.col - move.to.col);
                        moveScore += (8 - distance) * 0.5; // Чем ближе король к центру/безопасным позициям, тем выше оценка
                    }


                    // Защита пешек: дополнительные баллы за защиту пешек
                    moveScore += evaluatePawnProtection(boardCopy, 'black') * 0.3;


                    if (moveScore > bestScore) {
                        bestScore = moveScore;
                        bestMove = move;
                    }
                });


                // Если нет фильтруемых ходов, используем все доступные
                if (!inCheck) {
                    moves.forEach(move => {
                        const boardCopy = copyBoard(board);
                        const movingPiece = boardCopy[move.from.row][move.from.col];
                        const targetPiece = boardCopy[move.to.row][move.to.col];


                        // Выполнение хода на копии доски
                        boardCopy[move.to.row][move.to.col] = movingPiece;
                        boardCopy[move.from.row][move.from.col] = null;


                        // Пешечное превращение
                        if (movingPiece.type === 'pawn') {
                            if ((movingPiece.color === 'black' && move.to.row === 7)) {
                                boardCopy[move.to.row][move.to.col] = { type: 'queen', color: movingPiece.color };
                            }
                        }


                        // Оценка хода
                        let moveScore = evaluateBoard(boardCopy, turn);


                        // Приоритет захвата
                        if (targetPiece) {
                            moveScore += pieceValues[targetPiece.type] * 2; // Увеличиваем оценку за захват
                        }


                        // Приоритет продвижения пешек
                        if (movingPiece.type === 'pawn') {
                            moveScore += (movingPiece.color === 'black' ? (move.to.row - 1) : (6 - move.to.row)); // Для черных и белых пешек
                        }


                        // Приоритет постановки вилки конем
                        if (movingPiece.type === 'knight') {
                            const potentialForks = countForks(boardCopy, move.to.row, move.to.col, turn);
                            moveScore += potentialForks * 1.5; // Увеличиваем оценку за вилки
                        }


                        // Защита короля: дополнительные баллы за расстояние от короля до белых фигур
                        const kingPos = findKingPosition(boardCopy, 'black');
                        if (kingPos) {
                            const distance = Math.abs(kingPos.row - move.to.row) + Math.abs(kingPos.col - move.to.col);
                            moveScore += (8 - distance) * 0.5; // Чем ближе король к центру/безопасным позициям, тем выше оценка
                        }


                        // Защита пешек: дополнительные баллы за защиту пешек
                        moveScore += evaluatePawnProtection(boardCopy, 'black') * 0.3;


                        if (moveScore > bestScore) {
                            bestScore = moveScore;
                            bestMove = move;
                        }
                    });
                }


                return bestMove;
            }


            // Подсчет количества возможных вилок конем
            function countForks(board, row, col, turn) {
                let forks = 0;
                const knightMoves = [
                    { row: -2, col: -1 }, { row: -2, col: 1 },
                    { row: -1, col: -2 }, { row: -1, col: 2 },
                    { row: 1, col: -2 }, { row: 1, col: 2 },
                    { row: 2, col: -1 }, { row: 2, col: 1 }
                ];


                knightMoves.forEach(dir => {
                    const newRow = row + dir.row;
                    const newCol = col + dir.col;
                    if (isInside(newRow, newCol)) {
                        const piece = board[newRow][newCol];
                        if (piece && piece.color !== turn && piece.type !== 'king') {
                            forks++;
                        }
                    }
                });


                return forks;
            }


            // Оценка защиты пешек
            function evaluatePawnProtection(board, turn) {
                let protectionScore = 0;
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece && piece.type === 'pawn' && piece.color === turn) {
                            // Проверяем, защищена ли пешка другими фигурами
                            const defenderPositions = getPawnDefenders(board, row, col, turn);
                            protectionScore += defenderPositions.length * 0.5; // Добавляем баллы за каждого защитника
                        }
                    }
                }
                return protectionScore;
            }


            // Получение позиций фигур, защищающих пешку
            function getPawnDefenders(board, row, col, color) {
                const defenders = [];
                const directions = color === 'black' ? [
                    { row: -1, col: -1 }, { row: -1, col: 1 }
                ] : [
                    { row: 1, col: -1 }, { row: 1, col: 1 }
                ];


                directions.forEach(dir => {
                    const defenderRow = row + dir.row;
                    const defenderCol = col + dir.col;
                    if (isInside(defenderRow, defenderCol)) {
                        const defenderPiece = board[defenderRow][defenderCol];
                        if (defenderPiece && (defenderPiece.type === 'bishop' || defenderPiece.type === 'queen' || defenderPiece.type === 'rook' || defenderPiece.type === 'knight')) {
                            defenders.push({ row: defenderRow, col: defenderCol });
                        }
                    }
                });


                return defenders;
            }


            // Выполнение хода AI
            function performAIMove(aiMove) {
                if (!aiMove) return;
                makeMove(aiMove.from, aiMove.to);
                currentTurn = 'white';
                turnElement.textContent = 'Dragons';
                drawBoard();
            }


            // AI ход
            // (Функция уже реализована выше)


            // Выполнение залпа всех белых пешек
            function performAllSalvos() {
                let anySalvoPerformed = false;


                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const piece = board[row][col];
                        if (piece && piece.type === 'pawn' && piece.color === 'white' && piece.salvoCooldown === 0) {
                            performSalvo(row, col);
                            piece.salvoCooldown = 10; // Устанавливаем кулдаун
                            anySalvoPerformed = true;
                        }
                    }
                }


                if (anySalvoPerformed) {
                    drawBoard();
                } else {
                    alert('Залп недоступен. Осталось ходов до следующего залпа.');
                }
            }


            // Выполнение залпа пешкой (уже реализовано выше)


            // Рендеринг начальной доски
            drawBoard();
        </script>
</body>
</html>
